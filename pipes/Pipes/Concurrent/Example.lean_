/-
Examples for Pipes.Concurrent - demonstrating asynchronous communication patterns
-/
import Init.System.IO
import Std.Internal.Async.Basic
-- Assuming the Pipes.Concurrent module from the previous artifact

namespace Pipes.Concurrent.Examples

-- Re-export for convenience
open Pipes.Concurrent
open Std.Internal.IO.Async

-- | Game Events example - merging multiple event sources
inductive Event where
  | Harm : Nat ‚Üí Event
  | Heal : Nat ‚Üí Event
  | Quit : Event
  deriving Repr, BEq

def Event.toString : Event ‚Üí String
  | Harm n => s!"Harm {n}"
  | Heal n => s!"Heal {n}"
  | Quit => "Quit"

instance : ToString Event := ‚ü®Event.toString‚ü©

-- | User input producer - simulates user commands
def userInput : IO Event := do
  IO.println "Enter command (potion/quit/other): "
  let input ‚Üê (‚Üê IO.getStdin).getLine
  let command := input.trim
  match command with
  | "potion" => return Event.Heal 10
  | "quit" => return Event.Quit
  | _ => do
    IO.println "Invalid command"
    return Event.Harm 1  -- Invalid commands cause harm!

-- | Acid rain producer - periodic damage
def acidRainProducer (output : Output Event) : Async Unit := do
  let rec loop : Async Unit := do
    IO.sleep 2000  -- Wait 2 seconds
    let success ‚Üê output.send (Event.Harm 1)
    if success then loop else return ()
  loop

-- | User input producer
def userInputProducer (output : Output Event) : Async Unit := do
  let rec loop : Async Unit := do
    let event ‚Üê userInput
    let success ‚Üê output.send event
    if success && event != Event.Quit then loop else return ()
  loop

-- | Game event handler
def gameHandler (input : Input Event) : Async Unit := do
  let rec loop (health : Nat) : Async Unit := do
    IO.println s!"Health = {health}"
    match ‚Üê input.recv with
    | none =>
      IO.println "Game ended - no more events"
      return ()
    | some event => do
      match event with
      | Event.Harm n =>
        let newHealth := if health > n then health - n else 0
        if newHealth == 0 then
          IO.println "You died! Game over."
          return ()
        else
          loop newHealth
      | Event.Heal n => loop (health + n)
      | Event.Quit =>
        IO.println "Thanks for playing!"
        return ()
  loop 100

-- | Main game example
def gameExample : IO Unit := do
  IO.println "=== Game Example - Merging Event Sources ==="
  let (output, input) ‚Üê spawn unbounded

  -- Start acid rain in background
  background (acidRainProducer output)

  -- Start user input in background
  background (userInputProducer output)

  -- Run game handler
  let _ ‚Üê gameHandler.toIO
  return ()

-- | Work stealing example
def worker (id : Nat) (input : Input String) : Async Unit := do
  let rec loop : Async Unit := do
    match ‚Üê input.recv with
    | none =>
      IO.println s!"Worker #{id}: No more work"
      return ()
    | some job => do
      IO.sleep 1000  -- Simulate work taking 1 second
      IO.println s!"Worker #{id}: Processed '{job}'"
      loop
  loop

def workStealingExample : IO Unit := do
  IO.println "=== Work Stealing Example ==="
  let (output, input) ‚Üê spawn unbounded

  -- Start 3 workers
  let workers := Array.range 3
  let workerTasks ‚Üê workers.mapM fun i => async (worker (i + 1) input)

  -- Producer: send 10 jobs
  let producerTask ‚Üê async do
    for i in Array.range 10 do
      let success ‚Üê output.send s!"Job_{i + 1}"
      if !success then break
    IO.println "Producer finished"

  -- Wait for producer to finish, then seal mailbox
  let _ ‚Üê await producerTask
  IO.sleep 5000  -- Give workers time to finish

  return ()

-- | Broadcasting example
def broadcastListener (id : Nat) (input : Input String) : Async Unit := do
  let rec loop (count : Nat) : Async Unit := do
    if count >= 3 then  -- Each listener only takes 3 messages
      IO.println s!"Listener #{id}: Done after {count} messages"
      return ()
    else
      match ‚Üê input.recv with
      | none =>
        IO.println s!"Listener #{id}: Stream ended"
        return ()
      | some msg => do
        IO.println s!"Listener #{id}: Received '{msg}'"
        loop (count + 1)
  loop 0

def broadcastExample : IO Unit := do
  IO.println "=== Broadcast Example ==="

  -- Create two separate mailboxes
  let (output1, input1) ‚Üê spawn unbounded
  let (output2, input2) ‚Üê spawn unbounded

  -- Create broadcast output (combines both outputs)
  let broadcastOutput := output1 ++ output2

  -- Start listeners
  let listener1 ‚Üê async (broadcastListener 1 input1)
  let listener2 ‚Üê async (broadcastListener 2 input2)

  -- Broadcast messages
  let messages := #["Hello", "World", "Broadcast", "Test", "End"]
  for msg in messages do
    let success ‚Üê broadcastOutput.send msg
    IO.println s!"Broadcast sent: '{msg}' (success: {success})"
    IO.sleep 500

  -- Wait for listeners to finish
  let _ ‚Üê await listener1
  let _ ‚Üê await listener2

  return ()

-- | Latest value example (like a signal/reactive variable)
def temperatureSensor (output : Output Float) : Async Unit := do
  let rec loop (temp : Float) : Async Unit := do
    -- Simulate temperature readings every 100ms
    let newTemp := temp + (Float.sin (temp / 10.0)) * 2.0  -- Simulate fluctuation
    let success ‚Üê output.send newTemp
    if success then do
      IO.sleep 100
      loop newTemp
    else return ()
  loop 20.0  -- Start at 20¬∞C

def temperatureDisplay (input : Input Float) : Async Unit := do
  let rec loop : Async Unit := do
    match ‚Üê input.recv with
    | none =>
      IO.println "Temperature sensor disconnected"
      return ()
    | some temp => do
      IO.println s!"üå°Ô∏è  Current temperature: {temp:.1f}¬∞C"
      IO.sleep 1000  -- Update display every second
      loop
  loop

def latestValueExample : IO Unit := do
  IO.println "=== Latest Value Example (Temperature Sensor) ==="

  -- Use 'latest' buffer - always shows most recent temperature
  let (output, input) ‚Üê spawn (latest 18.0)  -- Default temperature

  -- Start fast sensor updates
  background (temperatureSensor output)

  -- Start slow display updates
  let displayTask ‚Üê async temperatureDisplay input

  -- Run for 10 seconds
  IO.sleep 10000

  IO.println "Temperature monitoring stopped"
  return ()

-- | Bounded buffer example showing backpressure
def fastProducer (output : Output Nat) : Async Unit := do
  let rec loop (n : Nat) : Async Unit := do
    IO.println s!"Producing: {n}"
    let success ‚Üê output.send n
    if success then do
      IO.sleep 100  -- Fast production
      loop (n + 1)
    else do
      IO.println "Producer: Output closed"
      return ()
  loop 1

def slowConsumer (input : Input Nat) : Async Unit := do
  let rec loop : Async Unit := do
    match ‚Üê input.recv with
    | none =>
      IO.println "Consumer: No more data"
      return ()
    | some n => do
      IO.println s!"    Consuming: {n}"
      IO.sleep 1000  -- Slow consumption
      loop
  loop

def backpressureExample : IO Unit := do
  IO.println "=== Backpressure Example (Bounded Buffer) ==="

  -- Small buffer size to demonstrate backpressure
  let (output, input) ‚Üê spawn (bounded 3)

  -- Start fast producer and slow consumer
  let producerTask ‚Üê async (fastProducer output)
  let consumerTask ‚Üê async (slowConsumer input)

  -- Let it run for a bit
  IO.sleep 8000

  IO.println "Backpressure demo finished"
  return ()

-- | Callback integration example
def callbackFramework (callback : String ‚Üí BaseIO Unit) : Async Unit := do
  let messages := #["Callback message 1", "Callback message 2", "Callback message 3"]
  for msg in messages do
    callback msg
    IO.sleep 1000

def callbackIntegrationExample : IO Unit := do
  IO.println "=== Callback Integration Example ==="

  let (output, input) ‚Üê spawn (bounded 1)

  -- Convert callback to stream
  let callbackTask ‚Üê async do
    callbackFramework (fun msg => do output.send msg; return ())

  -- Consume the stream
  let consumerTask ‚Üê async do
    let rec loop : Async Unit := do
      match ‚Üê input.recv with
      | none => return ()
      | some msg => do
        IO.println s!"Received from callback: '{msg}'"
        loop
    loop

  let _ ‚Üê await callbackTask
  let _ ‚Üê await consumerTask

  return ()

-- | Resource management example using withSpawn
def resourceExample : IO Unit := do
  IO.println "=== Resource Management Example ==="

  withSpawn unbounded fun (output, input) => do
    -- Resources are automatically cleaned up
    let producerTask ‚Üê async do
      for i in Array.range 5 do
        let success ‚Üê output.send s!"Message {i + 1}"
        IO.println s!"Sent: Message {i + 1} (success: {success})"
        IO.sleep 200

    let consumerTask ‚Üê async do
      let rec loop : Async Unit := do
        match ‚Üê input.recv with
        | none => return ()
        | some msg => do
          IO.println s!"Received: {msg}"
          loop
      loop

    let _ ‚Üê await producerTask
    let _ ‚Üê await consumerTask

    IO.println "Resource example completed - mailbox automatically sealed"
    return ()

-- | Main function to run all examples
def main : IO Unit := do
  IO.println "üöÄ Pipes.Concurrent Examples\n"

  -- Run examples with delays between them
  gameExample
  IO.sleep 1000

  workStealingExample
  IO.sleep 1000

  broadcastExample
  IO.sleep 1000

  latestValueExample
  IO.sleep 1000

  backpressureExample
  IO.sleep 1000

  callbackIntegrationExample
  IO.sleep 1000

  resourceExample

  IO.println "\n‚úÖ All examples completed!"

end Pipes.Concurrent.Examples
